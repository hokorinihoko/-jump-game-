<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ホコリのジャンプアップ</title>
  <style>
    :root{ --bg:#0b1220; --platform:#8bd3c7; --player:#ffd166; --text:#e6f0ff }
    html,body{height:100%;margin:0;font-family:system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Segoe UI", Roboto, "Yu Gothic", sans-serif;background:var(--bg);color:var(--text)}
    .wrap{display:flex;height:100vh;align-items:center;justify-content:center;gap:20px;padding:20px;box-sizing:border-box}
    canvas{background:linear-gradient(180deg,#071021 0%, #062032 60%);border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
    .ui{width:300px;max-width:30vw;color:var(--text)}
    h1{margin:0 0 8px 0;font-size:18px}
    p{margin:6px 0;font-size:13px;line-height:1.4}
    .controls{margin-top:12px}
    .btn{display:inline-block;padding:8px 12px;border-radius:8px;background:#123243;color:var(--text);cursor:pointer;margin-right:8px}
    .footer{margin-top:18px;font-size:12px;opacity:0.9}
    .score{font-weight:700;font-size:20px;margin-top:8px}
    @media(max-width:800px){.wrap{flex-direction:column}.ui{width:90vw;max-width:none}}
    #gameOverOverlay{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.55);display:flex;align-items:center;justify-content:center;flex-direction:column;color:#fff;font-size:22px;display:none;z-index:10;}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="480" height="720"></canvas>
    <div class="ui">
      <h1>ホコリのジャンプアップ</h1>
      <p>目標：右上を目指してジャンプ！落ちたらゲームオーバー。</p>
      <div class="score" id="score">スコア: 0</div>
      <div class="controls">
        <div><strong>操作</strong></div>
        <div>← → : 左右移動</div>
        <div>Space / Z / ↑ : ジャンプ</div>
        <div>R : リスタート / ボタンでも可</div>
      </div>
      <div style="margin-top:10px">
        <div class="btn" id="startBtn">ゲーム開始</div>
        <div class="btn" id="pauseBtn">一時停止</div>
      </div>
      <div class="footer">ノート: ブラウザでこのファイルを開いて遊んでね。スマホでもタッチで操作できるよ（左右ボタンは画面端をタップ）。</div>
    </div>
    <div id="gameOverOverlay">
      <div>ゲームオーバー</div>
      <div id="finalScore" style="margin-top:10px;">スコア: 0</div>
      <div style="margin-top:8px;font-size:16px;">Rキーまたはボタンでリスタート</div>
      <div class="btn" id="resetBtn">リセット</div>
    </div>
  </div>

  <script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height;

  let cameraY = 0;

  const player = {
    startX: W/2,
    startY: H - 120,
    x: W/2,
    y: H - 120,
    w: 32,
    h: 40,
    vx: 0,
    vy: 0,
    speed: 3.2,
    jumpPower: -10.5,
    onGround: false,
    maxSpeed: 5
  };

  const gravity = 0.45;
  const friction = 0.98;

  let platforms = [];
  const PLATFORM_WIDTH = 80;
  const PLATFORM_HEIGHT = 12;

  let running = false;
  let paused = false;
  let lastTimestamp = 0;
  let score = 0;
  let maxHeight = player.y;

  const keys = {};
  window.addEventListener('keydown', e => { keys[e.code] = true; if(e.code === 'KeyR'){ init(); start(); hideGameOver(); } });
  window.addEventListener('keyup', e => { keys[e.code] = false; });

  canvas.addEventListener('touchstart', e => { e.preventDefault(); const t = e.touches[0]; handleTouch(t.clientX); });
  canvas.addEventListener('touchmove', e => { e.preventDefault(); const t = e.touches[0]; handleTouch(t.clientX); });
  canvas.addEventListener('touchend', e => { e.preventDefault(); keys['ArrowLeft'] = false; keys['ArrowRight'] = false; });

  function handleTouch(x){
    const rect = canvas.getBoundingClientRect();
    const cx = x - rect.left;
    if (cx < rect.width*0.4){ keys['ArrowLeft'] = true; keys['ArrowRight'] = false; }
    else if (cx > rect.width*0.6){ keys['ArrowRight'] = true; keys['ArrowLeft'] = false; }
    else { keys['ArrowLeft'] = false; keys['ArrowRight'] = false; keys['Space'] = true; }
  }

  document.getElementById('startBtn').addEventListener('click', ()=>{ if(!running) { start(); hideGameOver(); } else { init(); start(); hideGameOver(); } });
  document.getElementById('pauseBtn').addEventListener('click', ()=>{ paused = !paused; document.getElementById('pauseBtn').textContent = paused ? '再開' : '一時停止'; });

  document.getElementById('resetBtn').addEventListener('click', () => { init(); start(); hideGameOver(); });

  function init(){
    cameraY = 0;
    platforms = [];
    player.x = player.startX;
    player.y = player.startY;
    player.vx = 0;
    player.vy = 0;
    player.onGround = false;
    maxHeight = player.y;
    score = 0;
    generateInitialPlatforms();
    paused = false;
    document.getElementById('pauseBtn').textContent = '一時停止';
    hideGameOver();
  }

  function generateInitialPlatforms(){
    const gap = 90;
    for(let i=0;i<20;i++){
      const x = Math.random()*(W-PLATFORM_WIDTH);
      const y = H - i*gap - 40;
      platforms.push({x,y,w:PLATFORM_WIDTH,h:PLATFORM_HEIGHT,type:'normal',vx:0});
    }
    platforms[0].x = W/2 - 60;
  }

  function spawnPlatform(y){
    const x = Math.random()*(W-PLATFORM_WIDTH);
    let type = 'normal';
    let vx = 0;
    if (Math.random() < 0.12){ type = 'moving'; vx = (Math.random()<0.5? -1:1) * (1+Math.random()*1.2); }
    if (Math.random() < 0.06) type = 'spring';
    platforms.push({x,y,w:PLATFORM_WIDTH,h:PLATFORM_HEIGHT,type,vx});
  }

  function checkPlatformCollision(p){
    if (player.vy > 0){
      const px1 = player.x - player.w/2;
      const px2 = player.x + player.w/2;
      const py = player.y + player.h/2;
      const platX1 = p.x;
      const platX2 = p.x + p.w;
      const platY = p.y;
      if (py <= platY + 6 && py + player.vy >= platY && px2 > platX1 && px1 < platX2){
        return true;
      }
    }
    return false;
  }

  function start(){
    if (running) return;
    running = true;
    lastTimestamp = performance.now();
    requestAnimationFrame(loop);
  }

  function loop(ts){
    if (!running) return;
    const dt = Math.min(34, ts - lastTimestamp);
    lastTimestamp = ts;
    if (!paused) update(dt/16);
    render();
    requestAnimationFrame(loop);
  }

  function update(delta){
    let move = 0;
    if (keys['ArrowLeft'] || keys['KeyA']) move -= 1;
    if (keys['ArrowRight'] || keys['KeyD']) move += 1;
    player.vx += move * 0.6 * player.speed * delta;
    player.vx *= friction;

    if (player.vx > player.maxSpeed) player.vx = player.maxSpeed;
    if (player.vx < -player.maxSpeed) player.vx = -player.maxSpeed;

    const jumpPressed = keys['Space'] || keys['KeyZ'] || keys['ArrowUp'];
    if (jumpPressed && player.onGround){ player.vy = player.jumpPower; player.onGround = false; }
    if (keys['Space'] && !navigator.maxTouchPoints) keys['Space'] = false;

    player.vy += gravity * delta;

    player.x += player.vx * delta;
    player.y += player.vy * delta;

    if (player.x < -player.w) player.x = W + player.w;
    if (player.x > W + player.w) player.x = -player.w;

    player.onGround = false;
    for (let p of platforms){
      if (checkPlatformCollision(p)){
        player.y = p.y - player.h/2;
        player.vy = 0;
        player.onGround = true;
        if (p.type === 'spring') player.vy = player.jumpPower * 1.6;
        if (p.type === 'moving') player.x += p.vx * 2;
      }
    }

    for (let p of platforms){
      if (p.type === 'moving'){
        p.x += p.vx * delta;
        if (p.x < 0 || p.x + p.w > W) p.vx *= -1;
      }
    }

    const topThreshold = H * 0.35;
    const targetCameraY = player.y - topThreshold;
    cameraY += (targetCameraY - cameraY) * 0.08; // カメラを滑らかに追従させる

    platforms = platforms.filter(p => p.y - cameraY < H + 400);

    if (player.y < maxHeight) maxHeight = player.y;
    score = Math.max(0, Math.floor(H - maxHeight));
    document.getElementById('score').textContent = 'スコア: ' + score;

    if (player.y - cameraY > H + 60){
      running = false;
      showGameOver();
    }

// プラットフォーム消去条件を緩める
platforms = platforms.filter(p => p.y - cameraY < H + 400 && p.y - cameraY > -200);

// 上方向にプラットフォームを補充（画面上に少し余裕を持たせる）
const topVisibleY = cameraY - 100;
let minY = Math.min(...platforms.map(p => p.y), player.y);

// プレイヤーが上方向に移動しているときだけ生成
if(player.vy < 0){ 
    while(minY > topVisibleY){
        const gap = 80 + Math.random()*20; // 高い位置ほど間隔が広くなる
        spawnPlatform(minY - gap);
        minY -= gap;
    }
}


  }

  function render(){
    ctx.clearRect(0,0,W,H);
    drawBackground();

    for (let p of platforms){
      const drawY = p.y - cameraY;
      ctx.fillStyle = '#0b2b2a';
      ctx.fillRect(p.x, drawY + 4, p.w, p.h);
      if (p.type === 'spring') ctx.fillStyle = '#ffd7a6';
      else if (p.type === 'moving') ctx.fillStyle = '#a6f0df';
      else ctx.fillStyle = '#8bd3c7';
      roundRect(ctx, p.x, drawY, p.w, p.h, 4, true, false);
      if (p.type === 'spring'){ ctx.fillStyle = '#c46a00'; ctx.fillRect(p.x + p.w/2 - 6, drawY - 6, 12, 6); }
    }

    const px = player.x;
    const py = player.y - cameraY;
    ctx.beginPath(); ctx.ellipse(px, py + player.h/2 + 8, player.w*0.6, 6, 0,0,Math.PI*2); ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fill();
    ctx.fillStyle = '#ffd166';
    roundRect(ctx, px - player.w/2, py - player.h/2, player.w, player.h, 6, true, false);
    ctx.fillStyle = '#1b2430'; ctx.fillRect(px - 6, py - 6, 4, 4); ctx.fillRect(px + 2, py - 6, 4, 4);

    ctx.fillStyle = '#e6f0ff'; ctx.font = '16px system-ui, sans-serif'; ctx.fillText('スコア: ' + score, 12, 22);

    if (!running && !document.getElementById('gameOverOverlay').style.display){
      ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(0,H/2 - 36, W, 72);
      ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='20px system-ui'; ctx.fillText('ゲーム停止中 - 開始ボタンかRで再開', W/2, H/2 + 6); ctx.textAlign='left';
    }
  }

  function showGameOver(){
    const overlay = document.getElementById('gameOverOverlay');
    document.getElementById('finalScore').textContent = 'スコア: ' + score;
    overlay.style.display = 'flex';
  }

  function hideGameOver(){
    document.getElementById('gameOverOverlay').style.display = 'none';
  }

  function drawBackground(){
    const grad = ctx.createLinearGradient(0,0,0,H);
    grad.addColorStop(0,'#071021'); grad.addColorStop(1,'#072033');
    ctx.fillStyle = grad; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = 'rgba(10,20,35,0.28)';
    for (let i=0;i<6;i++){
      const baseY = H - (i*40 + (cameraY*0.02 % 120));
      ctx.beginPath(); ctx.moveTo(-200, baseY);
      ctx.lineTo(120, baseY - 80 - i*6);
      ctx.lineTo(320, baseY - 20 - i*6);
      ctx.lineTo(540, baseY - 60 - i*6);
      ctx.lineTo(W+200, baseY);
      ctx.closePath(); ctx.fill();
    }
  }

  function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
    if (typeof stroke === 'undefined') stroke = true;
    if (typeof radius === 'undefined') radius = 5;
    if (typeof radius === 'number') radius = {tl: radius, tr: radius, br: radius, bl: radius};
    ctx.beginPath(); ctx.moveTo(x + radius.tl, y);
    ctx.lineTo(x + width - radius.tr, y); ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    ctx.lineTo(x + width, y + height - radius.br); ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
    ctx.lineTo(x + radius.bl, y + height); ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
    ctx.lineTo(x, y + radius.tl); ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    ctx.closePath(); if (fill) ctx.fill(); if (stroke) ctx.stroke();
  }

  window.addEventListener('resize', () => {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width; canvas.height = rect.height; W = canvas.width; H = canvas.height;
  });

  init();
  render();
  </script>
</body>
</html>
